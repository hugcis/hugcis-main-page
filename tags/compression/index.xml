<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Compression on Hugo Cisneros</title><link>https://hugocisneros.com/tags/compression/</link><description>Recent content in Compression on Hugo Cisneros</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 20 Dec 2022 16:59:00 +0100</lastBuildDate><atom:link href="https://hugocisneros.com/tags/compression/index.xml" rel="self" type="application/rss+xml"/><item><title>Huffman coding</title><link>https://hugocisneros.com/notes/huffman_coding/</link><pubDate>Tue, 20 Dec 2022 16:59:00 +0100</pubDate><guid>https://hugocisneros.com/notes/huffman_coding/</guid><description>tags Compression, Entropy coding Python implementation from heapq import heappush, heappop, heapify def huffman_coding(frequency_dict): # Create a heap of tuples (frequency, character, code) heap = [[frequency, [character, &amp;#34;&amp;#34;]] for character, frequency in frequency_dict.items()] heapify(heap) while len(heap) &amp;gt; 1: # Extract the two nodes with the lowest frequencies left, right = heappop(heap), heappop(heap) # Assign a &amp;#34;0&amp;#34; to the left child and a &amp;#34;1&amp;#34; to the right child for pair in left[1:]: pair[1] = &amp;#34;0&amp;#34; + pair[1] for pair in right[1:]: pair[1] = &amp;#34;1&amp;#34; + pair[1] # Merge the two nodes and add the resulting node back to the heap heappush(heap, [left[0] + right[0]] + left[1:] + right[1:]) # Extract the coding dictionary from the heap return dict(sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))) # Example usage frequency_dict = {&amp;#39;a&amp;#39;: 45, &amp;#39;b&amp;#39;: 13, &amp;#39;c&amp;#39;: 12, &amp;#39;d&amp;#39;: 16, &amp;#39;e&amp;#39;: 9, &amp;#39;f&amp;#39;: 5, &amp;#39;r&amp;#39;: 2, &amp;#39;q&amp;#39;: 1} print(huffman_coding(frequency_dict)) The code above outputs the following Python dictionary:</description></item><item><title>Graph compression</title><link>https://hugocisneros.com/notes/graph_compression/</link><pubDate>Thu, 30 Sep 2021 14:47:00 +0200</pubDate><guid>https://hugocisneros.com/notes/graph_compression/</guid><description> tags Compression, Graphs (Bouritsas et al. 2021)
Bibliography Giorgos Bouritsas, Andreas Loukas, Nikolaos Karalias, Michael M. Bronstein. July 5, 2021. "Partition and Code: Learning How to Compress Graphs". Arxiv:2107.01952 [cs, Math, Stat]. http://arxiv.org/abs/2107.01952.</description></item><item><title>Asymmetric numeral systems in Rust</title><link>https://hugocisneros.com/projects/asymmetric_numeral_systems_rust/</link><pubDate>Mon, 27 Sep 2021 09:49:45 +0200</pubDate><guid>https://hugocisneros.com/projects/asymmetric_numeral_systems_rust/</guid><description>Links Github repo Description This is a Rust implementation of the range variant of Asymmetric numeral systems (ANS). It is an entropy coding method which combines the compression ratio of arithmetic coding with the speed of Huffman coding, making it an essential algorithm which is included in many modern compression utilities.</description></item><item><title>Arithmetic coding</title><link>https://hugocisneros.com/notes/arithmetic_coding/</link><pubDate>Thu, 23 Sep 2021 09:07:00 +0200</pubDate><guid>https://hugocisneros.com/notes/arithmetic_coding/</guid><description> tags Compression, Entropy coding resources (Witten et al. 1987) Bibliography Ian H. Witten, Radford M. Neal, John G. Cleary. 1987. "Arithmetic Coding for Data Compression". Communications of the ACM 30 (6). ACM New York, NY, USA:520â€“40.</description></item><item><title>Entropy coding</title><link>https://hugocisneros.com/notes/entropy_coding/</link><pubDate>Thu, 23 Sep 2021 08:50:00 +0200</pubDate><guid>https://hugocisneros.com/notes/entropy_coding/</guid><description> tags Compression, Entropy</description></item><item><title>Lempel-Ziv-Welch algorithm</title><link>https://hugocisneros.com/notes/lempel_ziv_welch_algorithm/</link><pubDate>Tue, 04 May 2021 09:22:00 +0200</pubDate><guid>https://hugocisneros.com/notes/lempel_ziv_welch_algorithm/</guid><description>tags Compression, Complexity papers (Lempel, Ziv 1976; Ziv, Lempel 1977; Ziv, Lempel 1978; Welch 1984; Storer, Szymanski 1982) Context The LZW algorithm was originally designed as a complexity (&amp;ldquo;randomness&amp;rdquo;) metric for finite sequences (Lempel, Ziv 1976). It was then extended as a compression algorithm by the same authors to LZ77 (Ziv, Lempel 1977) and LZ78 (Ziv, Lempel 1978). Those last two are the basis of many well known and widely used compression utilities such as GIF, compress (LZW (Welch 1984) ) or DEFLATE, gzip (LZSS (Storer, Szymanski 1982)), etc.</description></item></channel></rss>